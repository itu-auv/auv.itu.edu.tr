[
  {
    "id": 10,
    "title": "Küçük Bir Vida, Büyük Bir Ders: ESC Kartımız Neden Yandı?",
    "author": "Mehmet Erkılıç",
    "date": "2025-04-11",
    "sub_team": "Elektronik",
    "image": "images/blog/esc_vida.jpeg", 
    "content": "<p>AUV aracımızda motor kontrolünü sağlamak için kullandığımız ESC kartları, ESC case'inin içinde güvenli bir şekilde yer alıyor. Ancak geçtiğimiz aylarda, hepimize güzel bir ders olacak bir olay yaşadık.</p><p>Mekanik ekip arkadaşlarımız ESC case montajını yaparken, farkında olmadan case'in içine bir civata düşürmüşler. Bu küçük vida, kartın üzerinde kısa devreye sebep oldu ve kartımızı tamamen kullanılamaz hale getirdi. Başta sorunun bir komponent kaynaklı olduğunu düşündük, tek tek parçaları değiştirerek çözüm aradık. Ancak ne yaptıysak sonuç alamadık.</p><p>Bir süre sonra anladık ki problem sadece bir komponentte değil, kartın tamamındaydı. Yanlış yere düşen bir vida, tüm ESC kartının yanmasına neden olmuştu.</p><p>Bu deneyim bize sadece dikkatli olmanın değil, doğru teşhis koymanın da ne kadar önemli olduğunu gösterdi. Sorunu tespit ettikten sonra kartı yeniden tasarladık, üretimini gerçekleştirdik ve sonunda kartımız yeniden çalışır hale geldi.</p><p>Bazen en büyük problemler, en küçük detaylarda gizli olabiliyor. Biz de bu süreçten önemli bir ders çıkardık: “Montajda son kontrol, en az tasarım kadar kritik.”</p>",
    "slug": "esc-karti-neden-yandi"
  },
  {
    "id": 9,
    "title": "Taluy Mini Gömülü Yazılımdaki Gelişmeler",
    "author": "Taşkın Ökmen",
    "date": "2025-03-08",
    "sub_team": "Elektronik",
    "image": "images/blog/mini_gomulu.jpeg",
    "content": "<p>Bu yazıda yeni aracımız Taluy Mini'nin gömülü yazılımındaki gelişmelerden bahsedeceğim.</p><p>Taluy Mini AUV üzerinde bulunan ana kart;  sensör okumaları ve ham verinin sürekli işlenmesi gibi tekrara binen bütün görevleri, ana karttaki entegre devrelerine gereken voltajda güç dağıtımını ve motorların sürülmesi için gerekli PWM oluşturması gibi işlemleri ana bilgisayardan soyutlayarak tek bir kartta birleştirmektedir. Bu sayede daha fazla mikrodenetleyici kullanmaktan ve mikrodenetleyiciler arasında haberleşmenin getirdiği ekstra gecikmeden kaçındık. Ayrıca, ana bilgisayarın görev yükünü ana karta paylaştırarak ana bilgisayarın asıl yarışma görevleri için daha verimli kullanılmasını sağladık</p><p>Karttaki sensör okumaları, fırçasız doğru akım motorlarının sürülmesi, ROS paketlerinin ethernet ile ana bilgisayara gönderilmesi ve ana kartın diğer mevcut görevlerinin eşzamanlı olacak şekilde yönetmek için kendi RTOS kütüphanemizi geliştirdik. AUV-RTOS, basit bir round-robin schedular içermekte ve araçtaki görevlerin düşük geçikme ile istenilen periyotlarda gerçekleşmesini sağlamaktadır.</p><p>Yeni aracımızda IMU sensörü olarak BNO055 kullandık. BNO'nun mutlak oryantasyon sağlaması ve üzerinde bulunan ARM Cortex-M0+ sayesinde sensor-fusion yapabilmesi gibi özellikleri dolayısıyla tercih ettik. IMU sensörünün testi ve kalibrasyonu için rviz'i -ROS'un 3D simülasyon uygulamasını- kullanarak test ettik. Ana karta bağlı diğer bir sensör olan Navquest Micro600 DVL'in mesajlarını çözümlemek için kendi sürücü yazılımımızı geliştirdik. Ana kartta bulunan MAX232 entegresi sayesinde, mikrodenetleyicinin UART çıkışının voltaj seviyesini DVL sensörünün RS-232 ile haberleşebilmesi için gereken voltaj seviyesine çıkararak DVL'in anakartla haberleşmesini sağladık.</p><p>Taluy Mini anakartının, Taluy expansion kartından farklı bir diğer özelliği ise ana bilgisayarla haberleşmek için UART yerine Ethernet kullanmasıdır. Ethernet üzerinde network ve transport katmanı olarak gömülü sistemlerde kullanılan lwIP TCP/IPv4 yığın kütüphanesini ve ana bilgisayar ile ROS paketleriyle haberleşebilmek için rosserial'in ethernet API'ını kullandık. Ethernet'in CRC32 hata tespiti ve host/client arasında geribildirim özelliklerine sahip olması sebebiyle ana kartta UART yerine ethernet haberleşmesine geçtik.</p>",
    "slug": "taluy-mini-gomulu-yazilim"
  },
  {
    "id": 8,
    "title": "Expansion Kartı: Bir Hata, Bir Gelişim",
    "author": "Ravza Betül Karakaş",
    "date": "2025-02-15",
    "sub_team": "Elektronik",
    "image": "images/blog/eski_expansion.jpeg",
    "content": "<p>Aracımızda kartlar arası iletişimi CAN Bus protokolüyle sağlıyoruz. Takım olarak, sistemin ihtiyaçlarına göre özel olarak tasarladığımız kartlarımızda CAN transceiver'ları gömülü olarak kullanıyoruz. Bu sayede kartlar arası haberleşmeyi güvenli ve kararlı bir şekilde sağlayabiliyoruz. Ancak sistemin bir diğer bileşeni olan Jetson'da doğrudan CAN transceiver desteği bulunmadığı için, Jetson ile araç kartları arasında köprü görevi gören bir expansion kartı tasarladık. Expansion kartı CAN sinyallerini alarak rosserial ile Jetson'a iletmekte. Böylece Jetson, diğer sistem modülleriyle sorunsuz şekilde iletişim kurabiliyor.</p><p>Bu sistemde her şey sorunsuz ilerliyordu, ta ki havuz testinden önceki hazırlıklarda expansion kartı Jetson'a yanlış yönde takılana kadar. Bu hata, kartın üzerindeki çipin yanmasına neden oldu.</p><p>Yaşanan bu talihsizlik sonrası yalnızca hasarlı kartı onarmakla kalmayıp, mevcut tasarımı da gözden geçirme kararı aldık. Bu süreçte, daha önce kullandığımız STM32F103 çipi yerine, daha güçlü ve hızlı olan STM32F446 çipine geçiyoruz. Bu yeni çip, hem işlem gücü hem de çevresel donanım desteği açısından bize daha fazla esneklik sunacak. </p>",
    "slug": "expansion-karti-hata-gelisim"
  },
    {
    "id": 7,
    "title": "Bir Masada Buluşan Su Altı Takımları",
    "author": "Zeynep Demirbaş",
    "date": "2025-02-10",
    "sub_team": "İş Geliştirme ve Operasyon",
    "image": "images/blog/blog_zeynep_tr.jpeg",
    "content": "<p>İTÜ AUV Takımı olarak okulumuz kampüsünde, ülkemizde su altı alanında çalışmalar yürüten lise ve üniversite takımlarını bir kahvaltı etkinliğinde bir araya getirdik.</p><p>Bu etkinliği düzenlerken amacımız; su altı alanında çalışan öğrencilerin tanışmasını, deneyimlerini paylaşmasını ve birbirleriyle dayanışma içinde olabilecekleri bir iletişim ağı oluşturmayı sağlamaktı.</p><p>Samimi bir kahvaltı ortamında başlayan etkinlik, takımların kendi araçları ve yaşadıkları süreçler üzerine sohbetleriyle devam etti. Ardından atölyemize geçerek araçlar üzerinde daha teknik ve birebir paylaşımlar yaptık. Günün ilerleyen saatlerinde oynadığımız su altı temalı oyunlar ise ortamı daha da sıcak hale getirdi.</p><p>İş Geliştirme ve Operasyon ekibi olarak bu süreçte; takımlara ulaşma, etkinliği planlama ve sonrasında iletişimi sürdürme görevlerini üstlendik. Etkinlik sonunda tüm katılımcıların yer aldığı bir WhatsApp grubu oluşturarak bu iletişimin etkinlik sonrasında da devam etmesini sağladık.</p><p>Bu buluşma, bizim için sadece bir etkinlik değil; su altı alanında çalışan öğrenciler arasında canlı bir komünitenin oluşmasına atılan küçük ama değerli bir adımdı.</p>",
    "slug": "bir-masada-bulusan-su-alti-takimlari"
  },
  {
    "id": 6,
    "title": "Akustik Lokalizasyon",
    "author": "Seren Sıla Uysal",
    "date": "2024-07-03",
    "sub_team": "Yazılım",
    "image": "images/blog/006.jpg",
    "content": "<p>Bu yazıda, geçen sezon yazılım ekibi üyelerine verilen ödevlerden birine bakacağız. Bu ödevde, akustik yerelleştirme tekniklerini kullanarak bir su altı pinger'ının (akustik verici) kesin yerini ve derinliğini belirlemeyi ele aldık. data.csv adlı bir dosyada sağlanan veriler, birden fazla akustik sensörle alınan ölçümleri içeren başlangıç ​​noktamızdı. Bu ölçümler, sensörlerin GPS koordinatlarını, sensörlerin su yüzeyinden derinliğini ve sensörlerden pinger'a olan mesafeleri içerir. Görevimiz, bu veri noktalarını kullanarak pinger'ın kesin enlemini, boylamını ve derinliğini belirlemekti.</p><p>Öncelikle veri işleme aşamasına geçtik. Verileri data.csv'den okuduk, doğru hesaplamalar için mesafe değerlerini ikiyle çarparak ayarladık. Daha sonra enlem, boylam ve derinlik sütunlarını merkezler olarak ve mesafe sütununu yarıçaplar olarak çıkardık.</p><p>Sonra, bir küre üzerindeki iki nokta arasındaki mesafeyi hesaplayan Haversine formülünü tanımladık. Bu formül, Dünya'nın eğriliğini göz önünde bulundurarak hesaplamalarımız için önemliydi.</p><p>Daha sonra hesaplanan yarıçap ile bilinen yarıçap arasındaki kare farkların toplamını hesaplayan rezidü fonksiyonuna geçtik. Bu fonksiyon hesaplamalarımızı optimize etmek için çok önemliydi.</p><p>Optimizasyon süreci için, merkezler dizisinin ortalaması olarak hesaplanan bir başlangıç ​​tahminiyle başladık. En küçük kareler yöntemini kullanarak, sensör ölçümlerini temsil eden kürelerin kesişim noktasını bulmayı amaçladık. Bu süreç, pinger'ın koordinatlarını hassasiyetle tahmin etmemize yardımcı oldu.</p><p>Tahmini koordinatlara sahip olduğumuzda, Folium kullanarak etkileşimli bir harita oluşturduk. Bu harita, sensör konumlarını ve tahmini pinger konumunu görselleştirmemizi sağladı. Her sensör konumu için daireler ve işaretleyiciler ve pinger için ayrı bir işaretleyici ekledik. Son olarak, kolay erişim ve inceleme için haritayı pingermap.html olarak kaydettik.</p><p>Çabalarımızın sonucu olarak pingerin tahmini koordinatları 42.43869 Enlem ve 18.58540 Boylam olarak belirlendi.</p>",
    "slug": "akustik-lokalizasyon"
  },
  {
    "id": 5,
    "title": "Pasif sonar projesi",
    "author": "Yusuf Çalışkan",
    "date": "2024-06-14",
    "sub_team": "Elektronik",
    "image": "images/blog/005.jpg",
    "content": "<p>Bu sene çalışma fırsatını bulduğum en büyük projelerden biri olan pasif sonar projesinden size bahsetmek istiyorum. Aracımızın bu seneki katılacağı Robosub 2024 yarışmasındaki yüzleşeceği en kritik problemlerden biri görev bölgelerinin belli bir frekansta tekrarlı ve kesik bir şekilde sinyal gönderen \"pinger\" adı verlien cihazlar ile işaretlenmiş olması. Aracımızın bu görevlere ulaşabilmesi için etkili bir şekilde dinleme yaparak ve bu iş için hazırlanmış algoritmasını kullanarak görev yerlerini ayırt edebilmesi gerekiyor.</p><p>Donanımsal anlamda bu görev için hidrofon denilen su altı mikrofonlarından yararlanıyoruz. Hidrofonlarımızdan aldığımız sinyalleri akustik işleme kartımızdan (APB) geçirerek ve daha sonrasında analog olan sinyalimizi dijital ortama aktararak hazırlanan algoritmamızda işlenebilir hale getiriyoruz. </p><p>Yazılımsal anlamda ise gelen sinyalin bir sinüs şeklinde olmasından yararlanarak tepe noktaları arasındaki voltaj değerlerini PWM benzeri değerlere bölerek bu değerler arasındaki gelen farklı sinyallerin geliş süreleri ve hidrofonlarımızın geometrik kendi aralarındaki açısal konumlarından yola çıkarak sinyalin geliş süresi ve aracımıza geliş açısını hesaplıyoruz. Bu bilgiyi kullanarak aracımızı sinyal kaynağına yönlendirerek görev bölgemizi bulabiliyoruz.</p>",
    "slug": "pasif-sonar-projesi"
  },
  {
    "id": 4,
    "title": "Anakart gömülü yazılımında gelişmeler",
    "author": "Nihat Arslan",
    "date": "2024-05-24",
    "sub_team": "Elektronik",
    "image": "images/blog/004.jpg",
    "content": "<p>Anakartın gömülü yazılımını geliştirme üzerinde çalışıyorum. Aracımız ROS ile çalıştığı için anakart üzerinde rosserial_arduino paket haberleşmesi kullanıyoruz. Bu paketleyici kütüphane, esasında anakartı sağlayıcı (Host) bilgisayar ile gerçek ROS konuşması yaptırmak yerine köprü görevi gören bir python yazılımıyla simüle ettiriyor. </p><p>Şu anda anakart üzerinden ping sonarlar okunuyor. Ping sonrarları bir ROS servisi aracılığıyla açıp kapatabiliyoruz. Ping sonarlar sayesinde su altında 30 derecelik aralıkla karşımızdaki nesnenin bize olan uzaklığını ölçebiliyoruz. Bu verileri matematiksel fonksiyonlara sokarak su altı haritalandırmamızın doğruluğunu arttırıyoruz. </p><p>Ayrıca anakartımız üzerinden torpido ateşleme sistemini kullanabiliyoruz. Bu özelliği bir rosservis çağırarak kullanıyoruz. Şu anda bir servis çağrıldığında o fonksiyon hariç tüm haberleşmeler fonksiyon işlevini bitirene kadar duruyor. Her ne kadar bu süre yarım saniye gibi kısa da olsa bu sorunun çözümü üzerinde uğraşıyoruz.  </p><p>Son olarak birçok özelliklerinin dışında anakartımız aslında güç bölücü devrelere sahip olan bir güç dağıtım kartıdır. Bu sayede birçok farklı voltaj seviyesi isteyen sensörlerimizi çalıştırabiliyoruz.</p>",
    "slug": "anakart-gomulu-yazilim"
  },
  {
    "id": 3,
    "title": "Simulink'te sensör füzyonu ve ROS bağlantısı",
    "author": "Emre Tezel",
    "date": "2024-05-09",
    "sub_team": "Yazılım",
    "image": "images/blog/003.jpg",
    "content": "<p>AUV Yazılım ekibinde uğraştığım projelerden bir tanesi, sensor birleşim algoritmalarının Simulink üzerinden modellenmesinin gerçekleştirilmesiydi. Aracın otonom hareket için hayati öneme sahip konum ve yönelim bilgilerini ölçen sensörler, belirli bir hata birikmesine ve gürültüye sahipler. Bu hatalar, Kalman Filtresi adı verilen bir matematiksel algoritmayla, çoğunlukla birden fazla sensörden gelen verilerin birleştirilmesiyle, düzeltilir ve iyileştirilir. </p><p>Kalman Filtresi algoritması, Simulink içinde bir blok olarak bulunmaktadır. Algoritmayı Simulink içinde modelledikten sonra, aracı çalıştırdığımız ROS ortamına Simulink'te bulunan C/C++ kodu oluşturma özelliği ile geçebiliyoruz. Program, ROS workspace'lerine uyarlı C++ kodu yaratımını sağlıyor.</p> <p>Simulink üzerinde modellemeyi gerçekleştirmek, modelin genel görünümüne daha görsel ve bütüncül bir bakış açısına sahip olmamamızı sağlamaktadır. Simulink ortamı ayrıca, veri inceleme ve hata giderimi süreçlerini bizim için kolaylaştırmaktadır.</p>",
    "slug": "simulink-sensor-fuzyonu"
  },
  {
    "id": 2,
    "title": "Robotik Gripper Tasarım Süreci",
    "author": "Taner Özpınar",
    "date": "2024-03-29",
    "sub_team": "Mekanik",
    "image": "images/blog/002.jpg",
    "content": "<p>Merhaba, size gripper tasarım sürecimizden biraz bahsetmek istiyorum. Öncelikle gripper, nesneleri manipüle etmeye ve yerlerini değiştirmeye yarar. Başlayalım...</p><p>Gripper v1: İlk tasarımımız, bevel gear içeren bir sistemdi. Bu sistemde, 2 dişli ve bunların arasında pinion dişli bulunuyordu. Tahrik gücü servo motor ile sağlanıyordu. Ancak, 3 boyutlu baskı alındığında pençelerin toleransları ve boyutlarında sorunlar yaşandı. Bu nedenle, tasarımı yeniden gözden geçirmek zorunda kaldık ve 2. versiyona geçtik.</p><p>Gripper v2: İlk versiyona kıyasla, gripper'ın boyutlandırmasını yeniden yaptık ve tasarımı %125 küçülttük. Pençeler arasına 0.3 mm tolerans verildi ve topoloji optimizasyonu yapılarak yanlarda gerekli boşluklar bırakıldı. Ancak, bevel gear sistemi nedeniyle dikey kullanım için uygun olmasına rağmen, servo motorun yer kaplaması nedeniyle aracın alt bölmesine konumlandırmada sorunlar yaşandı. Bu nedenle, yatay kullanım için 3. versiyona geçtik.</p><p>Gripper v3: Yeni bir tasarım stratejisi izleyerek her bir komponenti parametrik ve ayrı ayrı tasarladık. Önceki tasarımda birleşik ve bütün olarak çalışıyorduk, bu da ilerleyen aşamalarda bir şeyi düzeltmeyi zorlaştırıyordu. Bu yeni yaklaşım, tasarımı daha modüler ve esnek hale getirdi.</p><p>Umarım gripper tasarlarken karşılaştığımız zorluklar ve bu zorlukların üstesinden gelme yöntemlerimizi beğenmişsinizdir :) </p>",
    "slug": "robotik-gripper-tasarim"
  },
  {
    "id": 1,
    "title": "Yeni blog sayfası!",
    "author": "Kayra Pamukçu",
    "date": "2024-03-05",
    "sub_team": "İş Geliştirme ve Operasyon",
    "image": "images/blog/001.jpg",
    "content": "<p>Merhaba, sitemize bir blog sayfası eklemeye karar verdik. Burada aracımızın gelişim sürecini sizlerle paylaşacağız. Ne yazık ki dinamik web sayfası kullanmak bizim için bir opsiyon değil, bundan dolayı yeni bir blog yazısı eklemek istediğimizde doğrudan sayfanın kodunu modifiye etmemiz gerekiyor. Gelecekte görüşme dileğiyle :)</p>",
    "slug": "yeni-blog-sayfasi"
  },
  {
    "id": 11,
    "title": "Motorlu Torpido",
    "author": "Ravza Betül Karakaş",
    "date": "2026-01-22",
    "sub_team": "Elektronik",
    "image": "images/blog/motorlu_torpido.jpeg",
    "content": "<p>Bu yıl Taluy’da, yeni bir yaklaşımı denemek amacıyla motorlu bir torpido geliştiriyoruz. Hedefimiz, araçtan ayrıldıktan sonra belirli bir süre boyunca kendi başına ilerleyebilen deneysel bir sistem ortaya koymak. Torpido, araç üzerindeyken kablosuz şarj ile süper kapasitörünü dolduruyor. Fırlatma sonrasında ise süper kapasitörde depolanan enerji motoru besleyerek torpidonun ilerlemesini sağlıyor. Sistem, önceki tasarımlarımızda olduğu gibi reed röle ile tetikleniyor. Torpidonun ne kadar süreyle çalışacağı ise devre üzerindeki ayarlanabilir bir timer ile belirleniyor. Motor sürme, kablosuz şarj ve süper kapasitörün şarj–deşarj yollarını kapsayan elektriksel tasarım büyük ölçüde tamamlandı. Şu anda sistemin entegrasyon ve test süreçleri devam ediyor.</p>",
    "slug": "motorlu-torpido"
  },
  {
    "id": 12,
    "title": "Araç İçi Haberleşmede Mimari Bir Sadeleşme",
    "author": "Tolga Öztürk",
    "date": "2026-01-05",
    "sub_team": "Elektronik",
    "image": "images/blog/expansion.jpeg",
    "content": "<p>Bu yıl Taluy’da, araç içi haberleşme mimarisini sadeleştirmek amacıyla önemli bir adım attık. Geleneksel olarak, her bir alt sistem kendi haberleşme arayüzüne sahipti ve bu durum, sistem karmaşıklığını artırıyordu. Bu sorunu çözmek için, tüm alt sistemleri tek bir haberleşme hattı üzerinden birbirine bağlayan bir mimari geliştirdik. Bu yaklaşım, hem donanım hem de yazılım tarafında önemli avantajlar sağladı. Donanım tarafında, daha az kablolama ve daha basit bir PCB tasarımı elde ettik. Yazılım tarafında ise, haberleşme katmanını soyutlayarak, her bir alt sistemin kendi iç mantığına odaklanmasını sağladık. Bu sayede, hem geliştirme sürecini hızlandırdık hem de sistemin güvenilirliğini artırdık.</p>",
    "slug": "yeni-blog-sayfasi"
  },
  {
    "id": 13,
    "title": "AUV’ye havuç bağlamak | Bir navigasyon hikayesi",
    "author": "Emin Meydanoglu",
    "date": "2026-01-13",
    "sub_team": "Yazılım",
    "image": "images/blog/havuc.png",
    "content": "<p>Otonom sistemlerde navigasyon, robotun haritada belirlenmiş bir hedefe güvenle ve etrafı yıkmadan gitmesinden sorumlu sistemdir. Bu yazıda, taluy'un navigasyon sisteminde yaptığımız yenilikleri ve geliştirdiğimiz \"Havucu Takip Et\" metodunu anlatacağız.</p><h3><strong>Tek Kişilik Dev Kadro: Align Frame Controller</strong></h3><p>Align Frame Controller (AFC), robot üzerindeki herhangi bir frame'i dışarıdaki sabit veya hareketli bir frame ile hizalamak için geliştirilmiş basit bir kontrolcüdür. Çalışma mantığı oldukça nettir:</p><ol><li>İki frame arasındaki hata hesaplanır.</li><li>Bu hata bir P kontrolcü ile hız komutlarına dönüştürülür.</li><li>Hız komutları alt seviye kontrolcülere aktarılır.</li></ol><p>Bu basit yöntemi etkili bir navigasyon sistemi olarak kullanmak mümkün müdür? Taluy için geçmişte kullandığımız yöntem tam da buydu: taluy'dan hedef noktasına kadar belirli aralıklarla hareket edecek bir frame oluştururduk. Bu frame, robotun (umulur ki) takip edebileceği sabit bir hızla hedefe ilerlerdi. Ancak, robotun gerçekte ne yaptığı dikkate alınmadığından, robot çoğu zaman hedef frame'i yakalayamaz ve istenilen yol takip edilemezdi.</p><p>Ne mutlu ki, birkaç düzenlemeyle bu sistemi çok daha iyi hale getirebilirdik, ve yaptık:</p><h3>Havucu takip et</h3><p>Önceki sistemin temel sorunu, dinamik hedef frame'in robotun mevcut durumunu göz ardı etmesiydi. Robot osilasyonda kalmış olsa da, kontrolcüler çalışmıyor olsa da bu canlı frame kendisine sinyal verildiği anda harekete geçiyor ve belli bir hızda hedefe varıyordu. Bu nedenle robot sıklıkla hedef frame'e yetişemiyor ve rota takibinde sorunlar yaşanıyordu.</p><p>Biz yeni sistemde başlıca iki yeni özellik geliştirdik:</p><ol><li><p>Path tabanlı rota tanımlama</p><p>Robotun hedef noktasına ulaşmak için izleyeceği rotayı nav_msgs/Path mesaj türünde oluşturmaya başladık. Bu mesaj tipi sıralı noktaların birleşiminden oluşur. Bir fonksiyon eğrisinden farkı, her noktanın pozisyonla beraber bir oryantasyona da sahip olmasıdır.</p><pre><code>nav_msgs/Path:\n\nstd_msgs/Header header\n  uint32 seq\n  time stamp\n  string frame_id\n\ngeometry_msgs/PoseStamped[] poses\n  std_msgs/Header header\n    uint32 seq\n    time stamp\n    string frame_id\n  geometry_msgs/Pose pose\n    geometry_msgs/Point position\n    geometry_msgs/Quaternion orientation</code></pre><p>Bu sayede robotun izleyeceği yol açıkça tanımlanmış ve görselleştirilmiş olur.</p></li></ol><p><strong>2. Dinamik Hedef Frame Hesaplayıcı</strong></p><p>Robotun mevcut pozisyonunu sürekli dikkate alan, yol üzerindeki hedef noktayı dinamik olarak belirleyen bir algoritma geliştirdik. Yeni sistem, basitçe aşağıdaki adımları izler:</p><ol><li>Robotun konumu ve yol bilgisini alır.</li><li>Path üzerindeki noktaların robota göre Euclidian uzaklıklarını hesaplar.</li><li>Robota uzaklık değeri 1 metreye en yakın olan noktayı seçer. Bu da demektir ki, eğer tüm noktalar 1 metreden daha yakınsa, path'in son elemanını (index[-1]) seçer.<ol><li>bu frame, her zaman ama her zaman path noktalarından birisidir, ya da ikisi arasında interpole edilmiştir (çünkü onların arasından seçtik).</li></ol></li><li>Seçilen nokta robota göre bir frame'e dönüştürülüp align frame controller'a verilir.</li><li>Bu işlemler, saniyede 20 kez gerçekleşir.</li></ol><p>Dinamik frame hesaplayıcı fonksiyonumuz:</p><pre><code class=\"language-python\"\u003edef calculate_dynamic_target(\n    path: Path, robot_pose: PoseStamped, dynamic_target_lookahead_distance: float\n) -> Optional[PoseStamped]:\n\n    if not path.poses or dynamic_target_lookahead_distance <= 0:\n        return None\n\n    closest_index = find_closest_point_index(path, robot_pose)\n\n    # If closest to last point, return it\n    if closest_index >= len(path.poses) - 1:\n        return path.poses[-1]\n\n    # Walk along path segments until we've consumed dynamic_target_lookahead_distance\n    remaining_distance = dynamic_target_lookahead_distance\n    current_index = closest_index\n\n    while remaining_distance > 0 and current_index < len(path.poses) - 1:\n        segment_start = path.poses[current_index].pose\n        segment_end = path.poses[current_index + 1].pose\n\n        # Compute Euclidean distance between segment_start and segment_end.\n        dx = segment_end.position.x - segment_start.position.x\n        dy = segment_end.position.y - segment_start.position.y\n        dz = segment_end.position.z - segment_start.position.z\n        segment_distance = np.linalg.norm(np.array([dx, dy, dz]))\n\n        # Skip zero-length segments\n        if segment_distance < ZERO_DISTANCE_TOLERANCE:\n            current_index += 1\n            continue\n\n        # If we can place target on this segment\n        if remaining_distance <= segment_distance:\n            ratio = remaining_distance / segment_distance\n            dynamic_target_pose = PoseStamped()\n            dynamic_target_pose.header = path.header\n            dynamic_target_pose.pose.position.x = segment_start.position.x + ratio * dx\n            dynamic_target_pose.pose.position.y = segment_start.position.y + ratio * dy\n            dynamic_target_pose.pose.position.z = segment_start.position.z + ratio * dz\n            # Use the orientation of the segment end.\n            dynamic_target_pose.pose.orientation = segment_end.orientation\n            return dynamic_target_pose\n\n        remaining_distance -= segment_distance  # Move to next segment\n        current_index += 1\n\n    # If we've consumed all segments, return last pose as target\n    return path.poses[-1]</code></pre><p>Bu hesaplayıcı, bize robot hareket ettikçe ondan uzaklaşan ama mesafesini koruyan (1 metre) bir dinamik frame hediye etmiş olur. Bu sayede, eski sistemdeki koordinasyon sorunu ortadan kalkmış olur, çünkü dinamik frame artık robotun nerede olduğunu kaale almaktadır. Robot bir yere gitmezse, o da yola devam etmez. Robot dinamik target'ı takip eder, dinamik target rotayı takip eder, sonuç olarak taluy rotayı takip etmiş olur.</p><h3>Gelecek üzerine notlar</h3><p>Yeni navigasyon sistemimiz, eskisine göre çok daha başarılı olsa da ihtiyaçlarımıza tam karşılık veremiyor. En büyük eksikliklerinden biri, engelleri kaale almaması. Yani object avoidance'a sahip değil. Buna ihtiyacımız olacak. Bir sonraki seviye navigasyon sistemimiz ise yolda.</p>",
    "slug": "auv-havuc-baglamak"
  },
  {
    "id": 14,
    "title": "auv sosyal: takım ruhumuz güçleniyor",
    "author": "Sena Gülek",
    "date": "2026-01-02",
    "sub_team": "İş Geliştirme ve Operasyon",
    "image": "images/blog/auv_sosyal1.jpeg",
    "content": "<p>İTÜ AUV Takımı olarak sadece teknik işlerle uğraşmıyoruz, ekip içi iletişimi ve motivasyonu yüksek tutmak için sosyal etkinliklere de bayağı vakit ayırıyoruz. Yıl boyunca tüm alt ekiplerimizle bir çok etkinlik yaptık.</p><p>Ekip olarak kaynaşmak, teknik işlerde başarılı olmamızın arkasındaki en büyük sebeplerden biri aslında. Üyelerimiz birbirini iyi tanıdıkça ve rahat bir ortamda çalıştıkça, projelerdeki verimlilik de kendiliğinden artıyor. Bu yüzden yıl içinde bir sürü sosyal aktivite organize ettik: Takım için özel tasarlanmış oyunlar, spor etkinlikleri, piknik gibi sosyal organizasyonlar düzenledik. Bu aktiviteler sayesinde ekip içi iletişimimiz güçlendi ve takım ruhumuzu daha da sağlamlaştırdık. Bir de takımımızın websitesi ve çalışmaları için profesyonel bir fotoğraf çekimi yaptık.</p><p>Takım içi uyumu güçlendiren bu organizasyonlar, sezon boyunca yapacağımız çalışmalara katkı sağlamaya devam edecek.</p>",
    "slug": "auv-sosyal-takim-ruhu"
  }
  
]
